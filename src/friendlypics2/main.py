"""Main entry point module for the application"""
import logging
import sys
import os
import json
import tempfile
import shutil
from urllib.parse import urlparse
#from pathlib import Path

from qtpy.QtWidgets import QApplication, QMainWindow, QFileDialog, QProgressDialog
from qtpy.QtCore import Slot

import requests
from requests.exceptions import HTTPError
from PIL import Image

from friendlypics2.dialogs.pin_dump_dialog import PinDumpDialog
from friendlypics2.misc.gui_helpers import load_ui
#from http import client
#client.HTTPConnection.debuglevel = 1


# TODO: hook up exception handling
# TODO: set up logging
# TODO: try and make progress bar on top of application window always
# TODO: setup app configuration file for storing stuff like paths, caches of boards, etc.
# TODO: setup some kind of secret handler for api tokens and stuff
# TODO: setup project to use poetry (only 1 version to target)


class MyWindow(QMainWindow):
    """Main window interface"""
    def __init__(self):
        super().__init__()
        self._log = logging.getLogger(__name__)
        self.setWindowTitle("Friendly Pics")
        self.statusBar().showMessage('Ready')
        self._load_ui()

    def _load_ui(self):
        """Internal helper method that configures the UI for the main window"""
        load_ui("form.ui", self)

        # TODO: test the mac-specific shortcut keys for these on Windows
        self.actionImportFromPinterest.triggered.connect(self.pinterest_import)
        self.actionDownloadPinterestDump.triggered.connect(self.pinterest_dump)

        # Hack: for testing we convert menubar to non native
        # works around the bug where native menu bar on mac is read only on app launch
        # problem is non existent when running app from a .app package (ie: as generated by pyinstaller)
        # TODO: Disable this line when running under pyinstaller
        self.menuBar().setNativeMenuBar(False)

    @Slot()
    def pinterest_dump(self):
        """Menu handler for launching the pinterest dump operation"""
        # TODO: come up with naming convention for slots (ie: menu_pinterest_dump)
        obj = PinDumpDialog()
        res = obj.exec()
        self._log(res)
        # Load JSON summary of boards
        # populate combo box on dialog
        # launch combo and check results
        # if OK selected, start downloading paged response data for the
        # pins on the board and save somewhere like the desktop

    @Slot()
    def pinterest_import(self):
        """Menu handler for launching the pinterest download / import operation"""
        path_to_files, _ = QFileDialog.getOpenFileNames(
            self,
            caption="Select Dump Files",
            dir="~/",
            filter="Dump files (*.txt)")
        dump_data = list()
        for cur_file in path_to_files:
            print(f"Loading file {cur_file}")
            with open(cur_file, "r") as file_handle:
                temp = json.loads(file_handle.read())
                dump_data.append(temp)

        tot = 0
        for cur_dump in dump_data:
            tot += len(cur_dump["data"])

        progress_dlg = QProgressDialog(f"Downloading {tot} pins...", "Cancel", 0, tot, self)
        progress_dlg.setModal(True)

        counter = 1
        for cur_dump in dump_data:
            for cur_pin in cur_dump["data"]:
                progress_dlg.setValue(counter)
                progress_dlg.setLabelText(f"Downloading file {counter} of {tot}...")
                if progress_dlg.wasCanceled():
                    self.statusBar().showMessage("Operation aborted")
                    return
                self._download_file(cur_pin)
                counter += 1

        self.statusBar().showMessage("Success")

    def _download_file(self, json_response):
        """Helper method that downloads a pinterest file described by a json data block

        Args:
            json_response (dict):
                description of the pinterest pin to be downloaded
        """
        supported_types = [
            '.jpg',
            '.png',
            '.webp',
            '.gif'
        ]
        output_folder = os.path.expanduser("~/Desktop/pics")
        if not os.path.exists(output_folder):
            os.makedirs(output_folder)

        if "image" not in json_response:
            print(f"Skipping pin {json_response['id']}. No valid image")
            return

        image_data = json_response["image"]
        url = urlparse(image_data["original"]["url"])
        filename = os.path.basename(url.path)
        extension = os.path.splitext(filename)[-1]

        if extension not in supported_types:
            print("Skipping pin {0}. Unsupported format {1}".format(url, extension))
            return
        output_file = os.path.join(output_folder, filename)
        if os.path.exists(output_file):
            print(f"{filename} already exists. Skipping.")

        if extension == ".webp":
            tmp_dir = tempfile.mkdtemp()
            temp_file = os.path.join(tmp_dir, filename)

            self._download_pin(url, tmp_dir)

            img = Image.open(temp_file).convert("RGB")
            new_filename = os.path.splitext(filename)[0] + ".jpg"

            img.save(os.path.join(output_folder, new_filename), "jpeg")

            # TODO: Make the temp file handler a context manager for safety
            shutil.rmtree(tmp_dir)
        else:
            self._download_pin(url, output_folder)

    @staticmethod
    def _download_pin(url, output_folder):
        """helper method that performs the HTTP operation to download a file

        Args:
            url (str):
                path to the file to download
            output_folder (str):
                path to the folder where the file should be downloaded
        """
        # TODO: update to use a pathlib object for the file
        temp_filename = os.path.basename(url.path)
        output_file = os.path.join(output_folder, temp_filename)

        if os.path.exists(output_file):
            print(f"File already exists {output_file}")
            return
        try:
            response = requests.get(url.geturl(), stream=True)
            response.raise_for_status()
            #print(f"Download headers: {response.headers}")

            with open(output_file, "wb") as handle:
                for data in response.iter_content():
                    handle.write(data)
        except HTTPError as err:
            print(f"Failed to download pin {url.geturl()}")
            print(err)
            return

    def closeEvent(self, event):  # pylint: disable=invalid-name
        """event handler called when the application is about to close"""
        # TODO: check for unsaved work
        self._log("Shutting down")
        self._log(event)
        # if True:
        #     event.accept()
        # else:
        #     event.ignore()


def run(args):
    """Main entrypoint function

    Args:
        args (list): command line arguments to be passed to the application

    Returns:
        int: return code to report back to the shell with
    """
    app = QApplication(args)
    widget = MyWindow()
    widget.show()
    return app.exec_()


if __name__ == "__main__":
    sys.exit(run(sys.argv))
