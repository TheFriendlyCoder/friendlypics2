import sys
import os
import json
import tempfile
import shutil
from qtpy import uic
from qtpy.QtWidgets import QApplication, QMainWindow, QFileDialog, QProgressDialog, QDialog
from qtpy.QtCore import Slot, SLOT, SIGNAL
from urllib.parse import urlparse
from pathlib import Path
import requests
from PIL import Image
from requests.exceptions import HTTPError
#from http import client
#client.HTTPConnection.debuglevel = 1

# TODO: hook up exception handling
# TODO: set up logging
# TODO: try and make progress bar on top of application window always
class PinDumpDialog(QDialog):
    def __init__(self):
        super().__init__()
        self.load_ui()

    def load_ui(self):
        uic.loadUi("pinterest_dump.ui", self)

        self.connect(self.button_box, SIGNAL("accepted()"), self, SLOT("accept()"))
        self.connect(self.button_box, SIGNAL("rejected()"), self, SLOT("reject()"))
        self.refresh_board_button.clicked.connect(self._refresh_board)

    @Slot()
    def _refresh_board(self):
        print("Refreshing...")


class MyWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Friendly Pics")
        self.statusBar().showMessage('Ready')
        self.load_ui()

    def load_ui(self):
        uic.loadUi("form.ui", self)

        # TODO: test the mac-specific shortcut keys for these on Windows
        self.actionImportFromPinterest.triggered.connect(self.pinterest_import)
        self.actionDownloadPinterestDump.triggered.connect(self.pinterest_dump)

        # Hack: for testing we convert menubar to non native
        # works around the bug where native menu bar on mac is read only on app launch
        # problem is non existent when running app from a .app package (ie: as generated by pyinstaller)
        self.menuBar().setNativeMenuBar(False)

    @Slot()
    def pinterest_dump(self):
        self._obj = PinDumpDialog()
        res = self._obj.exec()
        print(res)
        # Load JSON summary of boards
        # populate combo box on dialog
        # launch combo and check results
        # if OK selected, start downloading paged response data for the
        # pins on the board and save somewhere like the desktop
        pass

    @Slot()
    def pinterest_import(self):
        path_to_files, _ = QFileDialog.getOpenFileNames(
            self,
            caption="Select Dump Files",
            dir="~/",
            filter="Dump files (*.txt)")
        dump_data = list()
        for cur_file in path_to_files:
            print(f"Loading file {cur_file}")
            with open(cur_file, "r") as fh:
                temp = json.loads(fh.read())
                dump_data.append(temp)

        tot = 0
        for cur_dump in dump_data:
            tot += len(cur_dump["data"])

        progress_dlg = QProgressDialog(f"Downloading {tot} pins...", "Cancel", 0, tot, self)
        progress_dlg.setModal(True)

        counter = 1
        for cur_dump in dump_data:
            for cur_pin in cur_dump["data"]:
                progress_dlg.setValue(counter)
                progress_dlg.setLabelText(f"Downloading file {counter} of {tot}...")
                if progress_dlg.wasCanceled():
                    self.statusBar().showMessage("Operation aborted")
                    return
                self._download_file(cur_pin)
                counter += 1

        self.statusBar().showMessage("Success")

    def _download_file(self, json_response):
        supported_types = [
            '.jpg',
            '.png',
            '.webp',
            '.gif'
        ]
        output_folder = os.path.expanduser("~/Desktop/pics")
        if not os.path.exists(output_folder):
            os.makedirs(output_folder)

        if "image" not in json_response:
            print(f"Skipping pin {json_response['id']}. No valid image")
            return

        image_data = json_response["image"]
        url = urlparse(image_data["original"]["url"])
        filename = os.path.basename(url.path)
        extension = os.path.splitext(filename)[-1]

        if extension not in supported_types:
            print("Skipping pin {0}. Unsupported format {1}".format(
                    url,
                    extension
                ))
            return
        output_file = os.path.join(output_folder, filename)
        if os.path.exists(output_file):
            print(f"{filename} already exists. Skipping.")

        if extension == ".webp":
            tmp_dir = tempfile.mkdtemp()
            temp_file = os.path.join(tmp_dir, filename)

            self._download_pin(url, tmp_dir)

            im = Image.open(temp_file).convert("RGB")
            new_filename = os.path.splitext(filename)[0] + ".jpg"

            im.save(os.path.join(output_folder, new_filename), "jpeg")

            # TODO: Make the temp file handler a context manager for safety
            shutil.rmtree(tmp_dir)
        else:
            self._download_pin(url, output_folder)

    def _download_pin(self, url, output_folder):
        temp_filename = os.path.basename(url.path)
        output_file = os.path.join(output_folder, temp_filename)

        if os.path.exists(output_file):
            print(f"File already exists {output_file}")
            return
        try:
            response = requests.get(url.geturl(), stream=True)
            response.raise_for_status()
            #print(f"Download headers: {response.headers}")

            with open(output_file, "wb") as handle:
                for data in response.iter_content():
                    handle.write(data)
        except HTTPError as err:
            print(f"Failed to download pin {url.geturl()}")
            print(err)
            return

    def closeEvent(self, event):
        # TODO: check for unsaved work
        if True:
            event.accept()
        else:
            event.ignore()


def main(args):
    """Main entrypoint function

    Args:
        args (list): command line arguments to be passed to the application

    Returns:
        int: return code to report back to the shell with
    """
    app = QApplication(args)
    widget = MyWindow()
    widget.show()
    return app.exec_()


if __name__ == "__main__":
    sys.exit(main(sys.argv))
